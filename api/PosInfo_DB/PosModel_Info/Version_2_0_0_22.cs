using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Symposium_DTOs.PosModel_Info
{
    [DisplayName("Ver : 2.0.0.22")]
    public class Version_2_0_0_22
    {
        public List<string> Ver_2_0_0_22 { get; }

        public Version_2_0_0_22()
        {
            Ver_2_0_0_22 = new List<string>();
            Ver_2_0_0_22.Add("CREATE FUNCTION [dbo].[parseJSON]( @JSON NVARCHAR(MAX)) \n"
                           + "/* \n"
                           + "-- Create by Phil Factor	15 November 2010 \n"
                           + "-- Update by Kaden Mai		21 August 2014 \n"
                           + "-- How to Use	http://mtkcode.blogspot.com/2014/08/parse-json-string-by-sql-script.html \n"
                           + "*/ \n"
                           + "RETURNS @hierarchy TABLE \n"
                           + "  ( \n"
                           + "   element_id INT IDENTITY(1, 1) NOT NULL, /* internal surrogate primary key gives the order of parsing and the list order */ \n"
                           + "   sequenceNo [int] NULL, /* the place in the sequence for the element */ \n"
                           + "   parent_ID INT,/* if the element has a parent then it is in this column. The document is the ultimate parent, so you can get the structure from recursing from the document */ \n"
                           + "   Object_ID INT,/* each list or object has an object id. This ties all elements to a parent. Lists are treated as objects here */ \n"
                           + "   NAME NVARCHAR(2000),/* the name of the object */ \n"
                           + "   StringValue NVARCHAR(MAX) NOT NULL,/*the string representation of the value of the element. */ \n"
                           + "   ValueType VARCHAR(10) NOT null /* the declared type of the value represented as a string in StringValue*/ \n"
                           + "  ) \n"
                           + "AS \n"
                           + "BEGIN \n"
                           + "	IF LTRIM(RTRIM(ISNULL(@JSON,''))) <> ''	 \n"
                           + "	BEGIN  \n"
                           + "	  DECLARE \n"
                           + "		@FirstObject INT, --the index of the first open bracket found in the JSON string \n"
                           + "		@OpenDelimiter INT,--the index of the next open bracket found in the JSON string \n"
                           + "		@NextOpenDelimiter INT,--the index of subsequent open bracket found in the JSON string \n"
                           + "		@NextCloseDelimiter INT,--the index of subsequent close bracket found in the JSON string \n"
                           + "		@Type NVARCHAR(10),--whether it denotes an object or an array \n"
                           + "		@NextCloseDelimiterChar CHAR(1),--either a '}' or a ']' \n"
                           + "		@Contents NVARCHAR(MAX), --the unparsed contents of the bracketed expression \n"
                           + "		@Start INT, --index of the start of the token that you are parsing \n"
                           + "		@end INT,--index of the end of the token that you are parsing \n"
                           + "		@param INT,--the parameter at the end of the next Object/Array token \n"
                           + "		@EndOfName INT,--the index of the start of the parameter at end of Object/Array token \n"
                           + "		@token NVARCHAR(200),--either a string or object \n"
                           + "		@value NVARCHAR(MAX), -- the value as a string \n"
                           + "		@SequenceNo int, -- the sequence number within a list \n"
                           + "		@name NVARCHAR(200), --the name as a string \n"
                           + "		@parent_ID INT,--the next parent ID to allocate \n"
                           + "		@lenJSON INT,--the current length of the JSON String \n"
                           + "		@characters NCHAR(36),--used to convert hex to decimal \n"
                           + "		@result BIGINT,--the value of the hex symbol being parsed \n"
                           + "		@index SMALLINT,--used for parsing the hex value \n"
                           + "		@Escape INT --the index of the next escape character \n"
                           + "    \n"
                           + "  \n"
                           + "	  DECLARE @Strings TABLE /* in this temporary table we keep all strings, even the names of the elements, since they are 'escaped' in a different way, and may contain, unescaped, brackets denoting objects or lists. These are replaced in the JSON string by tokens representing the string */ \n"
                           + "		( \n"
                           + "		 String_ID INT IDENTITY(1, 1), \n"
                           + "		 StringValue NVARCHAR(MAX) \n"
                           + "		) \n"
                           + "	  SELECT--initialise the characters to convert hex to ascii \n"
                           + "		@characters='0123456789abcdefghijklmnopqrstuvwxyz', \n"
                           + "		@SequenceNo=0, --set the sequence no. to something sensible. \n"
                           + "	  /* firstly we process all strings. This is done because [{} and ] aren't escaped in strings, which complicates an iterative parse. */ \n"
                           + "		@parent_ID=0; \n"
                           + "	  WHILE 1=1 --forever until there is nothing more to do \n"
                           + "		BEGIN \n"
                           + "		  SELECT \n"
                           + "			@start=PATINDEX('%[^a-zA-Z][\"]%', @json collate SQL_Latin1_General_CP850_Bin);--next delimited string \n"
                           + "		  IF @start=0 BREAK --no more so drop through the WHILE loop \n"
                           + "		  IF SUBSTRING(@json, @start+1, 1)='\"' \n"
                           + "			BEGIN --Delimited Name \n"
                           + "			  SET @start=@Start+1; \n"
                           + "			  SET @end=PATINDEX('%[^\\][\"]%', RIGHT(@json, LEN(@json+'|')-@start) collate SQL_Latin1_General_CP850_Bin); \n"
                           + "			END \n"
                           + "		  IF @end=0 --no end delimiter to last string \n"
                           + "			BREAK --no more \n"
                           + "		  SELECT @token=SUBSTRING(@json, @start+1, @end-1) \n"
                           + "		  --now put in the escaped control characters \n"
                           + "		  SELECT @token=REPLACE(@token, FROMString, TOString) \n"
                           + "		  FROM \n"
                           + "			(SELECT \n"
                           + "			  '\\\"' AS FromString, '\"' AS ToString \n"
                           + "			 UNION ALL SELECT '\\', '\' \n"
                           + "			 UNION ALL SELECT '\\/', '/' \n"
                           + "			 UNION ALL SELECT '\b', CHAR(08) \n"
                           + "			 UNION ALL SELECT '\f', CHAR(12) \n"
                           + "			 UNION ALL SELECT '\n', CHAR(10) \n"
                           + "			 UNION ALL SELECT '\r', CHAR(13) \n"
                           + "			 UNION ALL SELECT '\t', CHAR(09) \n"
                           + "			) substitutions \n"
                           + "		  SELECT @result=0, @escape=1 \n"
                           + "	  --Begin to take out any hex escape codes \n"
                           + "		  WHILE @escape>0 \n"
                           + "			BEGIN \n"
                           + "			  SELECT @index=0, \n"
                           + "			  --find the next hex escape sequence \n"
                           + "			  @escape=PATINDEX('%\\x[0-9a-f][0-9a-f][0-9a-f][0-9a-f]%', @token collate SQL_Latin1_General_CP850_Bin) \n"
                           + "			  IF @escape>0 --if there is one \n"
                           + "				BEGIN \n"
                           + "				  WHILE @index<4 --there are always four digits to a \\x sequence   \n"
                           + "					BEGIN \n"
                           + "					  SELECT --determine its value \n"
                           + "						@result=@result+POWER(16, @index) \n"
                           + "						*(CHARINDEX(SUBSTRING(@token, @escape+2+3-@index, 1), \n"
                           + "									@characters)-1), @index=@index+1 ; \n"
                           + "         \n"
                           + "					END \n"
                           + "					-- and replace the hex sequence by its unicode value \n"
                           + "				  SELECT @token=STUFF(@token, @escape, 6, NCHAR(@result)) \n"
                           + "				END \n"
                           + "			END \n"
                           + "		  --now store the string away \n"
                           + "		  INSERT INTO @Strings (StringValue) SELECT @token \n"
                           + "		  -- and replace the string with a token \n"
                           + "		  SELECT @JSON=STUFF(@json, @start, @end+1, \n"
                           + "						'@string'+CONVERT(NVARCHAR(5), @@identity)) \n"
                           + "		END \n"
                           + "	  -- all strings are now removed. Now we find the first leaf.  \n"
                           + "	  WHILE 1=1  --forever until there is nothing more to do \n"
                           + "	  BEGIN \n"
                           + "  \n"
                           + "	  SELECT @parent_ID=@parent_ID+1 \n"
                           + "	  --find the first object or list by looking for the open bracket \n"
                           + "	  SELECT @FirstObject=PATINDEX('%[{[[]%', @json collate SQL_Latin1_General_CP850_Bin)--object or array \n"
                           + "	  IF @FirstObject = 0 BREAK \n"
                           + "	  IF (SUBSTRING(@json, @FirstObject, 1)='{') \n"
                           + "		SELECT @NextCloseDelimiterChar='}', @type='object' \n"
                           + "	  ELSE \n"
                           + "		SELECT @NextCloseDelimiterChar=']', @type='array' \n"
                           + "	  SELECT @OpenDelimiter=@firstObject \n"
                           + "  \n"
                           + "	  WHILE 1=1 --find the innermost object or list... \n"
                           + "		BEGIN \n"
                           + "		  SELECT \n"
                           + "			@lenJSON=LEN(@JSON+'|')-1 \n"
                           + "	  --find the matching close-delimiter proceeding after the open-delimiter \n"
                           + "		  SELECT \n"
                           + "			@NextCloseDelimiter=CHARINDEX(@NextCloseDelimiterChar, @json, \n"
                           + "										  @OpenDelimiter+1) \n"
                           + "	  --is there an intervening open-delimiter of either type \n"
                           + "		  SELECT @NextOpenDelimiter=PATINDEX('%[{[[]%', \n"
                           + "				 RIGHT(@json, @lenJSON-@OpenDelimiter)collate SQL_Latin1_General_CP850_Bin)--object \n"
                           + "		  IF @NextOpenDelimiter=0 \n"
                           + "			BREAK \n"
                           + "		  SELECT @NextOpenDelimiter=@NextOpenDelimiter+@OpenDelimiter \n"
                           + "		  IF @NextCloseDelimiter<@NextOpenDelimiter \n"
                           + "			BREAK \n"
                           + "		  IF SUBSTRING(@json, @NextOpenDelimiter, 1)='{' \n"
                           + "			SELECT @NextCloseDelimiterChar='}', @type='object' \n"
                           + "		  ELSE \n"
                           + "			SELECT @NextCloseDelimiterChar=']', @type='array' \n"
                           + "		  SELECT @OpenDelimiter=@NextOpenDelimiter \n"
                           + "		END \n"
                           + "	  ---and parse out the list or name/value pairs \n"
                           + "	  SELECT \n"
                           + "		@contents=SUBSTRING(@json, @OpenDelimiter+1, \n"
                           + "							@NextCloseDelimiter-@OpenDelimiter-1) \n"
                           + "	  SELECT \n"
                           + "		@JSON=STUFF(@json, @OpenDelimiter, \n"
                           + "					@NextCloseDelimiter-@OpenDelimiter+1, \n"
                           + "					'@'+@type+CONVERT(NVARCHAR(5), @parent_ID)) \n"
                           + "	  WHILE (PATINDEX('%[A-Za-z0-9@+.e]%', @contents collate SQL_Latin1_General_CP850_Bin))<>0 \n"
                           + "		BEGIN \n"
                           + "		  IF @Type='Object' --it will be a 0-n list containing a string followed by a string, number,boolean, or null \n"
                           + "			BEGIN \n"
                           + "			  SELECT \n"
                           + "				@SequenceNo=0,@end=CHARINDEX(':', ' '+@contents)--if there is anything, it will be a string-based name. \n"
                           + "			  SELECT  @start=PATINDEX('%[^A-Za-z@][@]%', ' '+@contents collate SQL_Latin1_General_CP850_Bin)--AAAAAAAA \n"
                           + "			  SELECT @token=SUBSTRING(' '+@contents, @start+1, @End-@Start-1), \n"
                           + "				@endofname=PATINDEX('%[0-9]%', @token collate SQL_Latin1_General_CP850_Bin), \n"
                           + "				@param=RIGHT(@token, LEN(@token)-@endofname+1) \n"
                           + "			  SELECT \n"
                           + "				@token=LEFT(@token, @endofname-1), \n"
                           + "				@Contents=RIGHT(' '+@contents, LEN(' '+@contents+'|')-@end-1) \n"
                           + "			  SELECT  @name=stringvalue FROM @strings \n"
                           + "				WHERE string_id=@param --fetch the name \n"
                           + "			END \n"
                           + "		  ELSE \n"
                           + "			SELECT @Name=null,@SequenceNo=@SequenceNo+1 \n"
                           + "		  SELECT \n"
                           + "			@end=CHARINDEX(',', @contents)-- a string-token, object-token, list-token, number,boolean, or null \n"
                           + "		  IF @end=0 \n"
                           + "			SELECT  @end=PATINDEX('%[A-Za-z0-9@+.e][^A-Za-z0-9@+.e]%', @Contents+' ' collate SQL_Latin1_General_CP850_Bin) \n"
                           + "			  +1 \n"
                           + "		   SELECT \n"
                           + "			 @start=PATINDEX('%[^A-Za-z0-9@+.e][A-Za-z0-9@+.e][\\-]%', ' '+@contents collate SQL_Latin1_General_CP850_Bin) \n"
                           + "			-- Edited: add more condition [\\-] in order to detect negative number 08-20-2014 \n"
                           + "		  --select @start,@end, LEN(@contents+'|'), @contents  \n"
                           + "		  SELECT \n"
                           + "			@Value=RTRIM(SUBSTRING(@contents, @start, @End-@Start)), \n"
                           + "			@Contents=RIGHT(@contents+' ', LEN(@contents+'|')-@end) \n"
                           + "		  IF SUBSTRING(@value, 1, 7)='@object' \n"
                           + "			INSERT INTO @hierarchy \n"
                           + "			  (NAME, SequenceNo, parent_ID, StringValue, Object_ID, ValueType) \n"
                           + "			  SELECT @name, @SequenceNo, @parent_ID, SUBSTRING(@value, 8, 5), \n"
                           + "				SUBSTRING(@value, 8, 5), 'object' \n"
                           + "		  ELSE \n"
                           + "			IF SUBSTRING(@value, 1, 6)='@array' \n"
                           + "			  INSERT INTO @hierarchy \n"
                           + "				(NAME, SequenceNo, parent_ID, StringValue, Object_ID, ValueType) \n"
                           + "				SELECT @name, @SequenceNo, @parent_ID, SUBSTRING(@value, 7, 5), \n"
                           + "				  SUBSTRING(@value, 7, 5), 'array' \n"
                           + "			ELSE \n"
                           + "			  IF SUBSTRING(@value, 1, 7)='@string' \n"
                           + "				INSERT INTO @hierarchy \n"
                           + "				  (NAME, SequenceNo, parent_ID, StringValue, ValueType) \n"
                           + "				  SELECT @name, @SequenceNo, @parent_ID, stringvalue, 'string' \n"
                           + "				  FROM @strings \n"
                           + "				  WHERE string_id=SUBSTRING(@value, 8, 5) \n"
                           + "			  ELSE \n"
                           + "				IF @value IN ('true', 'false') \n"
                           + "				  INSERT INTO @hierarchy \n"
                           + "					(NAME, SequenceNo, parent_ID, StringValue, ValueType) \n"
                           + "					SELECT @name, @SequenceNo, @parent_ID, @value, 'boolean' \n"
                           + "				ELSE \n"
                           + "				  IF @value='null' \n"
                           + "					INSERT INTO @hierarchy \n"
                           + "					  (NAME, SequenceNo, parent_ID, StringValue, ValueType) \n"
                           + "					  SELECT @name, @SequenceNo, @parent_ID, @value, 'null' \n"
                           + "				  ELSE \n"
                           + "					IF PATINDEX('%[^0-9]%', @value collate SQL_Latin1_General_CP850_Bin)>0 \n"
                           + "					  INSERT INTO @hierarchy \n"
                           + "						(NAME, SequenceNo, parent_ID, StringValue, ValueType) \n"
                           + "						SELECT @name, @SequenceNo, @parent_ID, @value, 'real' \n"
                           + "					ELSE \n"
                           + "					  INSERT INTO @hierarchy \n"
                           + "						(NAME, SequenceNo, parent_ID, StringValue, ValueType) \n"
                           + "						SELECT @name, @SequenceNo, @parent_ID, @value, 'int' \n"
                           + "		  if @Contents=' ' Select @SequenceNo=0 \n"
                           + "		END \n"
                           + "	  END \n"
                           + "		INSERT INTO @hierarchy (NAME, SequenceNo, parent_ID, StringValue, Object_ID, ValueType) \n"
                           + "		SELECT '-',1, NULL, '', @parent_id-1, @type \n"
                           + "	END \n"
                           + "	RETURN \n"
                           + "END");
        }
    }
}
